{"ast":null,"code":"import * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { warnOnce } from '../../utils/warn-once.mjs';\nconst getChildKey = child => child.key || \"\";\nfunction updateChildLookup(children, allChildren) {\n  children.forEach(child => {\n    const key = getChildKey(child);\n    allChildren.set(key, child);\n  });\n}\nfunction onlyElements(children) {\n  const filtered = [];\n  // We use forEach here instead of map as map mutates the component key by preprending `.$`\n  Children.forEach(children, child => {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = _ref => {\n  let {\n    children,\n    custom,\n    initial = true,\n    onExitComplete,\n    exitBeforeEnter,\n    presenceAffectsLayout = true,\n    mode = \"sync\"\n  } = _ref;\n  // Support deprecated exitBeforeEnter prop\n  if (exitBeforeEnter) {\n    mode = \"wait\";\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, \"Replace exitBeforeEnter with mode='wait'\");\n    }\n  }\n  // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n  let [forceRender] = useForceUpdate();\n  const forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n  if (forceRenderLayoutGroup) forceRender = forceRenderLayoutGroup;\n  const isMounted = useIsMounted();\n  // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n  const filteredChildren = onlyElements(children);\n  let childrenToRender = filteredChildren;\n  const exiting = new Set();\n  // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n  const presentChildren = useRef(childrenToRender);\n  // A lookup table to quickly reference components by key\n  const allChildren = useRef(new Map()).current;\n  // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n  const isInitialRender = useRef(true);\n  useIsomorphicLayoutEffect(() => {\n    isInitialRender.current = false;\n    updateChildLookup(filteredChildren, allChildren);\n    presentChildren.current = childrenToRender;\n  });\n  useUnmountEffect(() => {\n    isInitialRender.current = true;\n    allChildren.clear();\n    exiting.clear();\n  });\n  if (isInitialRender.current) {\n    return React.createElement(React.Fragment, null, childrenToRender.map(child => React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      initial: initial ? undefined : false,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode\n    }, child)));\n  }\n  // If this is a subsequent render, deal with entering and exiting children\n  childrenToRender = [...childrenToRender];\n  // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n  const presentKeys = presentChildren.current.map(getChildKey);\n  const targetKeys = filteredChildren.map(getChildKey);\n  // Diff the present children with our target children and mark those that are exiting\n  const numPresent = presentKeys.length;\n  for (let i = 0; i < numPresent; i++) {\n    const key = presentKeys[i];\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    }\n  }\n  // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n  if (mode === \"wait\" && exiting.size) {\n    childrenToRender = [];\n  }\n  // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n  exiting.forEach(key => {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    const child = allChildren.get(key);\n    if (!child) return;\n    const insertionIndex = presentKeys.indexOf(key);\n    const onExit = () => {\n      allChildren.delete(key);\n      exiting.delete(key);\n      // Remove this child from the present children\n      const removeIndex = presentChildren.current.findIndex(presentChild => presentChild.key === key);\n      presentChildren.current.splice(removeIndex, 1);\n      // Defer re-rendering until all exiting children have indeed left\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        if (isMounted.current === false) return;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n    childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode\n    }, child));\n  });\n  // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n  childrenToRender = childrenToRender.map(child => {\n    const key = child.key;\n    return exiting.has(key) ? child : React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode\n    }, child);\n  });\n  if (process.env.NODE_ENV !== \"production\" && mode === \"wait\" && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its mode is set to \\\"wait\\\". This will lead to odd visual behaviour.\");\n  }\n  return React.createElement(React.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(child => cloneElement(child)));\n};\nexport { AnimatePresence };","map":{"version":3,"names":["React","useContext","useRef","cloneElement","Children","isValidElement","useForceUpdate","useIsMounted","PresenceChild","LayoutGroupContext","useIsomorphicLayoutEffect","useUnmountEffect","warnOnce","getChildKey","child","key","updateChildLookup","children","allChildren","forEach","set","onlyElements","filtered","push","AnimatePresence","_ref","custom","initial","onExitComplete","exitBeforeEnter","presenceAffectsLayout","mode","process","env","NODE_ENV","forceRender","forceRenderLayoutGroup","isMounted","filteredChildren","childrenToRender","exiting","Set","presentChildren","Map","current","isInitialRender","clear","createElement","Fragment","map","isPresent","undefined","presentKeys","targetKeys","numPresent","length","i","indexOf","add","size","get","insertionIndex","onExit","delete","removeIndex","findIndex","presentChild","splice","has","console","warn"],"sources":["/Users/tristan/Documents/GitHub/portolio-starter/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"sourcesContent":["import * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { warnOnce } from '../../utils/warn-once.mjs';\n\nconst getChildKey = (child) => child.key || \"\";\nfunction updateChildLookup(children, allChildren) {\n    children.forEach((child) => {\n        const key = getChildKey(child);\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = \"sync\", }) => {\n    // Support deprecated exitBeforeEnter prop\n    if (exitBeforeEnter) {\n        mode = \"wait\";\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, \"Replace exitBeforeEnter with mode='wait'\");\n        }\n    }\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    let [forceRender] = useForceUpdate();\n    const forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n    if (forceRenderLayoutGroup)\n        forceRender = forceRenderLayoutGroup;\n    const isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    const filteredChildren = onlyElements(children);\n    let childrenToRender = filteredChildren;\n    const exiting = new Set();\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    const presentChildren = useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    const allChildren = useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    const isInitialRender = useRef(true);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(() => {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exiting.clear();\n    });\n    if (isInitialRender.current) {\n        return (React.createElement(React.Fragment, null, childrenToRender.map((child) => (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child)))));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = [...childrenToRender];\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    const presentKeys = presentChildren.current.map(getChildKey);\n    const targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    const numPresent = presentKeys.length;\n    for (let i = 0; i < numPresent; i++) {\n        const key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (mode === \"wait\" && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach((key) => {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        const child = allChildren.get(key);\n        if (!child)\n            return;\n        const insertionIndex = presentKeys.indexOf(key);\n        const onExit = () => {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                if (isMounted.current === false)\n                    return;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map((child) => {\n        const key = child.key;\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\n    });\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        childrenToRender.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    return (React.createElement(React.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map((child) => cloneElement(child))));\n};\n\nexport { AnimatePresence };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}